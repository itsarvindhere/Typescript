So far, whatever we saw was existing Javascript constructs to handle narrowing. For example, the typeof operator, instanceof operator, in operator and so on.

Sometimes you want more direct control over how types change throughout your code.

What if we were able to define our own type guards?

For example, what if we can define functions that return whether some value is of a specific type or not?

In Typescript, we can use "Type predicates" to create user-defined guards.

    type Fish = { swim: () => void };
    type Bird = { fly: () => void };

So in the above code, we have two types. One has the "swim" function while other has "fly" function. We saw in the "in operator" narrowing that we can use the "in" operator to check if a value is of type Fish or Bird.

How can we define some function that returns whether a value is Fish or Bird.


    function isFish(pet: Fish | Bird): pet is Fish {
       return (pet as Fish).swim !== undefined;
    }

Note the return type of this function. It says "pet is Fish". What is this?

Well, this is something called "Type Predicate" in Typescript.

A predicate takes the form "parameterName is Type", where 
"parameterName" must be the name of a parameter from the current function signature.

Since we have "pet" as the name of the parameter in isFish method, we say "pet is Fish".

Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.

So, we can now use this function as -

    if (isFish(pet)) {
        pet.swim();
    } else {
        pet.fly();
    }

Notice that TypeScript not only knows that pet is a "Fish" in the if branch; it also knows that in the else branch, you donâ€™t have a Fish, so you must have a Bird.

Ofcourse the above code doesn't really show a good use case of this Type Predicate.

But, suppose if we have an array of "Fish | Bird" values and we want to filter out the ones that are of type "Fish".

Suppose we have the following array - 

    const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];

The getSmallPet() will either return a "Fish" type or "Bird" type value.

Now, to filter it, we can use our isFish method.

    const underWater1: Fish[] = zoo.filter(isFish);

Or, we can be more specific by saying -

    const underWater2: Fish[] = zoo.filter(isFish) as Fish[];

And let's say we want to filter out the Fish types but we also want to make sure if pet name is "sharky", then it is not added to the array. In some complex cases as well, we can use the Type Predicates -

    const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
        if (pet.name === "sharkey") return false;
        return isFish(pet);
    });


