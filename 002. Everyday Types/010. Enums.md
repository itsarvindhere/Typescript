Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.

They alow a developer to define a set of named constants. Typescript offers both Numbe-based and String-based Enums.

Enums in TypeScript are usually used to represent a determined number of options for a given value. This data is arranged in a set of key/value pairs. While the keys must be strings, as with JavaScript objects in general, the values for enum members are often auto-incremented numbers that mainly serve to distinguish one member from the other. 

# NUMERIC ENUMS IN TYPESCRIPT

Enums with only number values are called numeric enums.

To define an Enum in Typescript, we use the "enum" keyword, followed by the name of that enum. Then, you will have a block inside curly brackets where you will define the enum members.

For example, let's say we have to define an enum "Direction" which will have four members in it. We can define it like this - 

    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }

So, this enum "Direction" is representing all the directions. The reason why an Enum is a perfect data structure here is because there are always only four options for directions - Up, Down, Left and Right.

Note how "Up" is initialized by "1" and others are not initialized. The thing is, when we initialize any member in an enum by a number, all the following members will get auto incremented values.

For example, "Down" will get a value of 2, "Left" will get a value of 3, and "Right" will get a value of 4.

But, is this initialization of first member necessary? NO! We can even write - 

    enum Direction {
        Up,
        Down,
        Left,
        Right,
    }

In this case, "Up" will get a value 0, "Down" will get a value 1 and so on. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.

Note that Enums are not a feature offered in JavaScript. So, when you compile your .ts file into .js file where the .ts file contains Enums, the .js file will not have the same code.

For example, if our .ts file has this enum -

    enum Direction {
        Up,
        Down,
        Left,
        Right
    }

And we compile this file, then we will see that in .js file, we will have -

    var Direction;
    (function (Direction) {
        Direction[Direction["Up"] = 0] = "Up";
        Direction[Direction["Down"] = 1] = "Down";
        Direction[Direction["Left"] = 2] = "Left";
        Direction[Direction["Right"] = 3] = "Right";
    })(Direction || (Direction = {}));

So, you can see that to have an enum-like data structure in javascript, some complex code has to be written. But the same can be achieved in Typescript using enums.

## USING AN ENUM

So, once we create an enum, how can we use it?

Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:

For example, if we have the following enum - 

    enum UserResponse {
        No = 0,
        Yes = 1,
    }

And there is a function - 

    function respond(recipient: string, message: any): void {
        // ...
    }

We can even declare types using the enum name. For example, we can say that the "message" should be of type "UserResponse" -

    function respond(recipient: string, message: UserResponse): void {
        // ...
    }

This would mean we would have to pass the values when calling the function as - 

    respond("John", UserResponse.No);
    respond("John", UserResponse.Yes);

If you pass value that is not compatible with the enum type of your message variable, Typescript will display an error. For example, if you try to write - 

    respond("John", "No");

Typescript will say - Argument of type '"No"' is not assignable to parameter of type 'UserResponse'.

So, "message" can only be one of the members of the UserResponse enum.

One advantage of "Numeric" enums is that, you can also set the value of your variables to numeric values.

In above example, we can also write - 

    response("John", 0)

And the code will work without any issue. Because, inside UserResponse enum, 0 is the value of a member so 0 is a valid value that can be passed. Same is the case with 1. Again, this will only work with "Numeric" enums.

# STRING ENUMS IN TYPESCRIPT

As the name suggests, in String Enums, the values of members are Strings, not numbers. For example - 

    enum Direction {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT",
    }

Each member has to be a contant initialized with a string or with another string enum member.

Ofcourse this means there is no "auto-increment" behavior as numeric enums.

While string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though reverse mapping can often help). 

String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.

Now, one thing to note here is that, if you have an string enum with the first memeber initialized with some string, then, the following members also need to be initialized with either a number or a string. The reason is simply, because the first member is initialized with a string, Typescript will not know how to automatically set the values for the following members. If the first member had a number as its value, then Typescript would've just auto incremented the value for each following member. But that cannot be done in case of a string.

So, if you write - 

    enum Direction {
        Up = "Up",
        Down,
        Left,
        Right
    }

An error will be thrown for all the other memebers after "Up" saying - 

    Enum member must have initializer.

But, this was not the case when Up was initialized with a number.

Now, this also means that you can initialize the last member with a string and not all the members before it and this will be a valid code.

    enum Direction {
        Up,
        Down,
        Left,
        Right = "Right"
    }

Because in this case, Typescript will auto-assign values for "Up", "Down" and "Left" as 0, 1, and 2. Whereas for "Right", the value is "Right".

And with this, we can see that it does not matter that an enum can only have string values for all members or number values for all members.

Enums can be heterogeneous, meaning they can be mixed with string and numeric members.

# BI-DIRECTIONAL ENUM MEMBERS

There is one thing that cannot be done with string enums but it is possible with numeric enums.

If we have following enum - 

    enum Direction {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT"
    }

And we have a function as - 

    function print(direction: Direction) {
        console.log(direction);
    }

We can call this function only by passing one of these values -

    print(Direction.Up)
    print(Direction.Down)
    print(Direction.Left)
    print(Direction.Right)

It is not possible to call this function by doing - 

    print("Up")
    print("Down")
    print("Left")
    print("Right")

Remember that in case of numeric enums, we were able to call the function by passing both the members as well as the values and there was no error. But why is this the case?

That's because of how the enums in Typescript are converted into Javascript code.

Upon TypeScript compilation, enums are translated into JavaScript objects. 

However, there are a few features of enums that differentiate them from objects. They offer a more stable data structure for storing constant members than traditional JavaScript objects, and also offer bi-directional referencing for enum members. 

Let's suppose, we have the following Enum - 

    enum Direction {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT"
    }

As we can see, this is a String enum because all members have string values. 

Now, when this code is compile to javascript, we get this - 

    var Direction;
    (function (Direction) {
        Direction["Up"] = "UP";
        Direction["Down"] = "DOWN";
        Direction["Left"] = "LEFT";
        Direction["Right"] = "RIGHT";
    })(Direction || (Direction = {}));

We see that a new variable "Direction" is created with no value initially. Then, there is an Immediately Invoked Function Expression or IIFE which takes this variable as an input while also setting its value as an empty object ({}) if its value is not already set.

And inside the function, the code then assigns multiple properties to this "Direction" object.

Notice that each property is one member of your original enum, with the values set to the enum’s member value.

And that's pretty much it. That's how String Enums are translated to Javascript.

But, what about Numeric Enums, is the process the same for them?

Let's take this enum - 

    enum Direction {
        Up,
        Down,
        Left,
        Right"
    }

This will be the code in JavaScript - 

    var Direction;
    (function (Direction) {
        Direction[Direction["Up"] = 0] = "Up";
        Direction[Direction["Down"] = 1] = "Down";
        Direction[Direction["Left"] = 2] = "Left";
        Direction[Direction["Right"] = 3] = "Right";
        Direction[Direction[""] = 4] = "";
    })(Direction || (Direction = {}));

Did you notice something?

In addition to each member of the enum becoming a property of the object (CardinalDirection["Up"] = 0), the enum also creates a key for each number and assigns the string as the value.

    Direction[Direction["Up"] = 0] = "Up";

In the case of Up, Direction["Up"] = 0 returns the value 0, and CardinalDirection[0] = "Up" assigns the value "North" to the key "0".

This allows for a Bi-Directional relationship between the names of the numeric numbers and their values.

This means, if you do -

    console.log(Direction.Up);

This will give "1" as the output

And if you do -

    console.log(Direction[0]);

This will give "Up" as the output.

And this becomes more clear if you console log the "Direction" object that Javascript code creates - 

    {
        '0': 'Up',
        '1': 'Down',
        '2': 'Left',
        '3': 'Right',
        Up: 0,
        Down: 1,
        Left: 2,
        Right: 3
    }

You will see that there are both sets of key/value pairs that create the bi-directionality effect.

And this Bi-Directionality is the reason why if a variable has a type as a Numeric Enum, we can pass that variable a value that is not only the member of that enum, but also the value of any member.

And even if there is an enum that has at least one member with a numeric value, the Javascript code will generate the bi-directional code for that member.

For example, if we had - 

    enum Direction {
        Up,
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT"
    }

Here, the value for "Up" will be 0 which is a number. 

So, when converted to JavaScript, this will be the "Direction" object - 

    { 
        '0': 'Up', 
        Up: 0, 
        Down: 'DOWN', 
        Left: 'LEFT', 
        Right: 'RIGHT'
    }

Note how for the enum member that had a numeric value, the object has a bi-directional mapping. But that is not the case with the members with a string value.